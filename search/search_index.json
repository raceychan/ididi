{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ididi","text":"<p>Genius simplicity, unmathced power.</p> <p>ididi is 100% test covered and strictly typed.</p> <p>No Container, No Provider, No Wiring, just Python</p>"},{"location":"#information","title":"Information","text":"<p>Documentation:  https://raceychan.github.io/ididi </p> <p>Source Code:   https://github.com/raceychan/ididi</p>"},{"location":"#install","title":"Install","text":"<pre><code>$ pip install ididi\n</code></pre>  To view viusal dependency graph, install `graphviz`  <pre><code>$ pip install \"ididi[graphviz]\"\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from ididi import use, entry, AsyncResource\n\nasync def conn_factory(engine: AsyncEngine) -&gt; AsyncGenerator[AsyncConnection, None]:\n    async with engine.begin() as conn:\n        yield conn\n\nclass UnitOfWork:\n    def __init__(self, conn: AsyncConnection=use(conn_factory)):\n        self._conn = conn\n\n@entry\nasync def main(command: CreateUser, uow: UnitOfWork):\n    await uow.execute(build_query(command))\n\nawait main(CreateUser(name='user'))\n</code></pre> <p>This would create a <code>UnitOfWork</code> instance with a connection from <code>conn_factory</code> when <code>main</code> is called.</p>"},{"location":"#why-ididi","title":"Why Ididi?","text":"<p>ididi helps you do this while stays out of your way, you do not need to create additional classes like <code>Container</code>, <code>Provider</code>, <code>Wire</code>, nor adding lib-specific annotation like <code>Closing</code>, <code>Injectable</code>, etc.</p> <p>ididi provides unique powerful features that most alternatives don't have, such as support to inifinite number of context-specific nested sopce, lazydependent, advanced circular dependency detection, plotting, etc.</p> <p>Let's now explore these fantastic feaures in the <code>Features</code> section.</p>"},{"location":"#to-di-or-not-to-di-this-is-my-question","title":"To di, or not to di, this is my question","text":"<p>If you</p> <ul> <li>Are not familar with dependency injection, or OOP in general.</li> <li>Can't come up with cases where it would be useful.</li> <li>You fee like <code>it's java</code> and you have <code>javaphobia</code>.</li> </ul> <p>Let's discuss in the <code>Introduction</code> section.</p>"},{"location":"FAQ/","title":"FAQ","text":""},{"location":"FAQ/#faq","title":"FAQ","text":"How do I override, or provide a default value for a dependency?        you can use `dg.node` to create a factory to override the value. you can also have dependencies in your factory, and they will be resolved recursively.  <pre><code>class Config:\n    def __init__(self, env: str = \"prod\"):\n        self.env = env\n\n@dg.node\ndef config_factory() -&gt; Config:\n    return Config(env=\"test\")\n</code></pre>      How do i override a dependent in test?       you can use `dg.node` with a factory method to override the dependent resolution.  <pre><code>class Cache: ...\n\nclass RedisCache(Cache):\n    ...\n\nclass MemoryCache(Cache):\n    ...\n\n@dg.node\ndef cache_factory(...) -&gt; Cache:\n    return RedisCache() \n\nin your conftest.py:\n\n@dg.node\ndef memory_cache_factory(...) -&gt; Cache:\n    return MemoryCache()    \n</code></pre>  as this follows LSP, it works both with ididi and type checker.    How do I make ididi reuse a dependencies across different dependent?    by default, ididi will reuse the dependencies across different dependent, you can change this behavior by setting `reuse=False` in `dg.node`.  <pre><code>@dg.node(reuse=False) # True by default\nclass AuthService: ...\n</code></pre>"},{"location":"features/","title":"Features","text":""},{"location":"features/#core","title":"Core","text":""},{"location":"features/#automatic-dependencies-injection","title":"Automatic dependencies injection","text":"<p>You can use generator/async generator to create a resource that needs to be closed. NOTE:</p> <ol> <li>resources, if set to be reused, will be shared across different dependents only within the same scope, and destroyed when the scope is exited.</li> <li>async resource in a sync dependent is not supported, but sync resource in a async dependent is supported.  </li> </ol> <pre><code>from ididi import Graph\n\ndg = Graph()\n\n@dg.node\nasync def get_db(client: Client) -&gt; ty.AsyncGenerator[DataBase, None]:\n    db = DataBase(client)\n    assert client.is_opened\n    try:\n        await db.connect()\n        yield db\n    finally:\n        await db.close()\n\n@dg.entry\nasync def main(db: DataBase, sql: str) -&gt; ty.Any:\n    res = await db.execute(sql)\n    return res\n\nassert await main(sql=\"select money from bank\")\n</code></pre>"},{"location":"features/#using-scope-to-manage-resources","title":"Using Scope to manage resources","text":"<ul> <li>Infinite nested scope is supported.</li> <li>Parent scope can be accssed by child scope(within the same context)</li> <li>Resources will be shared across dependents only withint the same scope(reuse needs to be True)</li> <li>Resources will be automatically closed and destroyed when the scope is exited.</li> <li> <p>Classes that implment <code>contextlib.AbstractContextManager</code> or <code>contextlib.AbstractAsyncContextManager</code> are also considered to be resources and can/should be resolved within scope.</p> </li> <li> <p>Scopes are separated by context</p> </li> </ul> <p>[!NOTE] If you have two call stack of <code>a1 -&gt; b1</code> and <code>a2 -&gt; b2</code>,     Here <code>a1</code> and <code>a2</code> are two calls to the same function <code>a</code>,     then, in <code>b1</code>, you can only access scope created by the <code>a1</code>, not <code>a2</code>.</p> <p>This is particularly useful when you try to separate resources by route, endpoint, request, etc.</p>"},{"location":"features/#async-or-not-works-either-way","title":"Async, or not, works either way","text":"<pre><code>@dg.node\ndef get_resource() -&gt; ty.Generator[Resource, None, None]:\n    res =  Resource()\n    yield res\n    res.close()\n\nwith dg.scope() as scope:\n    resource = scope.resolve(Resource)\n\n# For async generator\nasync with dg.ascope() as scope:\n    resource = await scope.resolve(Resource)\n</code></pre>"},{"location":"features/#contexted-scope","title":"Contexted Scope","text":"<p>You can use dg.use_scope to retrive most recent scope, context-wise, this allows your to have access the scope without passing it around, e.g.</p> <pre><code>async def service_factory():\n    async with dg.ascope() as scope:\n        service = scope.resolve(Service)\n        yield service\n\n@app.get(\"users\")\nasync def get_user(service: Service = Depends(service_factory))\n    await service.create_user(...)\n</code></pre> <p>Then somewhere deep in your service.create_user call stack</p> <pre><code>async def create_and_publish():\n    uow = dg.use_scope().resolve(UnitOfWork)\n    async with uow.trans():\n        user_repo.add_user(user)\n        event_store.add(user_created_event)\n</code></pre> <p>Here <code>dg.use_scope()</code> would return the same scope you created in your <code>service_factory</code>.</p>"},{"location":"features/#named-scope","title":"Named Scope","text":"<p>You can create infinite level of scopes by assigning hashable name to scopes</p> <pre><code># at the top most entry of a request\nasync with dg.ascope(request_id) as scope:\n    ...\n</code></pre> <p>now scope with name <code>request_id</code> is accessible everywhere within the request context</p> <pre><code>request_scope = dg.use_scope(request_id)\n</code></pre> <p>[!NOTE] Two scopes or more with the same name would follow most recent rule.</p>"},{"location":"features/#nested-nmaed-scope","title":"Nested Nmaed Scope","text":"<pre><code>async with dg.ascope(app_name) as app_scope:\n    async with dg.ascope(router) as router_scope:\n        async with dg.ascope(endpoint) as endpoint_scope:\n            async with dg.ascope(user_id) as user_scope:\n                async with dg.ascope(request_id) as request_scope:\n                    ...\n</code></pre> <p>For any functions called within the request_scope, you can get the most recent scope with <code>dg.use_scope()</code>, or its parent scopes, i.e. <code>dg.use_scope(app_name)</code> to get app_scope.</p> <p>Note that since scope in context-specific, you will need to pass your scope to new thread if needed.</p> <p>For example, To use scope in background task, you would need to explicitly pass scope to your task</p> <pre><code>@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(write_notification, dg.use_scope(), email, message=\"some notification\")\n    return {\"message\": \"Notification sent in the background\"}\n\ndef write_notification(scope: SyncScope, email: str, message=\"\"):\n    with open(\"log.txt\", mode=\"w\") as email_file:\n        content = f\"notification for {email}: {message}\"\n        email_file.write(content)\n        scope.resolve(MessageQueue).publish(\"Email Sent\")\n\n    # To search parent scope:\n    parent_scope = scope.get_scope(name)\n</code></pre>"},{"location":"features/#menually-register-a-singleton","title":"Menually register a singleton","text":"<p>If you have an object built without Graph, yet want it to be injected elsewhere use <code>Graph.register_singleton</code></p> <pre><code>class Singleton:\n    ...\n\nsingleton = Singleton()\n\ndg = Graph.register_singleton(singleton)\n\nassert dg.resolve(Singleton) is singleton\n</code></pre>"},{"location":"features/#circular-dependency-detection","title":"Circular Dependency Detection","text":"<p>ididi would detect if circular dependency exists, if so, ididi would give you the circular path</p> <p>For example:</p> <pre><code>class A:\n    def __init__(self, b: \"B\"):\n        self.b = b\n\n\nclass B:\n    def __init__(self, a: \"C\"):\n        self.a = a\n\n\nclass C:\n    def __init__(self, d: \"D\"):\n        pass\n\n\nclass D:\n    def __init__(self, a: A):\n        self.a = a\n\n\ndef test_advanced_cycle_detection():\n    \"\"\"\n    DependentNode.resolve_forward_dependency\n    \"\"\"\n    dag = Graph()\n\n    with pytest.raises(CircularDependencyDetectedError) as exc_info:\n        dag.analyze(A)\n    assert exc_info.value.cycle_path == [A, B, C, D, A]\n</code></pre> <p>You can call <code>Graph.analyze_all</code> on app start to statically resolve all your noded classes, and let ididi get ready for resolve them at upcoming calls.</p>"},{"location":"features/#runtime-override","title":"Runtime override","text":"<pre><code>dg = Graph()\n\nclass Inner:\n    def __init__(self, value: str = \"inner\"):\n        self.value = value\n\n@dg.node\nclass Outer:\n    def __init__(self, inner: Inner):\n        self.inner = inner\n\n# Override nested dependency\ninstance = dg.resolve(Outer, inner=Inner(value=\"overridden\"))\nassert instance.inner.value == \"overridden\"\n</code></pre>"},{"location":"features/#visualize-the-dependency-graph","title":"Visualize the dependency graph","text":"<p>[!NOTE] You will need to install graphviz to be able to use Visualizer</p> <pre><code>from ididi import Graph, Visualizer\ndg = Graph()\n\nclass ConfigService:\n    def __init__(self, env: str = \"test\"):\n        self.env = env\n\n\nclass DatabaseService:\n    def __init__(self, config: ConfigService):\n        self.config = config\n\n\nclass CacheService:\n    def __init__(self, config: ConfigService):\n        self.config = config\n\n\nclass BaseService:\n    def __init__(self, db: DatabaseService):\n        self.db = db\n\n\nclass AuthService(BaseService):\n    def __init__(self, db: DatabaseService, cache: CacheService):\n        super().__init__(db)\n        self.cache = cache\n\n\nclass UserService:\n    def __init__(self, auth: AuthService, db: DatabaseService):\n        self.auth = auth\n        self.db = db\n\n\nclass NotificationService:\n    def __init__(self, config: ConfigService):\n        self.config = config\n\n\nclass EmailService:\n    def __init__(self, notification: NotificationService, user: UserService):\n        self.notification = notification\n        self.user = user\n\ndg.analyze(EmailService)\nvs = Visualizer(dg)\nvs.view # use vs.view in jupyter notebook, or use vs.save(path, format) otherwise\nvs.save(path, format)\n</code></pre> <p></p>"},{"location":"introduction/","title":"Introduction","text":""},{"location":"introduction/#terminology","title":"Terminology","text":"<p>what do we mean by these words</p> <p><code>dependent</code>: a class, or a function that requires arguments to be built/called.</p> <p><code>dependency</code>: an object that is required by a dependent.</p> <p><code>factory</code>: a function that is used to build the dependent, in case where dependent is a function, factory is the dependent.</p> <p><code>resource</code>: a dependent that implements the contextlib.AbstractAsync/ContextManager, or has an async/sync generator as its factory, is considered a resource.</p> <p><code>static resolve</code>: resursively build node from dependent type, but does not create the instance of the dependent type.</p> <p><code>resolve</code>: recursively resolve the dependent and its dependencies, then create an instance of the dependent type.</p> <p><code>entry</code>: a special type of node, where it has no dependents and its factory is itself.</p> <p><code>dg</code>: an instance of the Graph class.</p>"},{"location":"introduction/#what-and-why","title":"What and why","text":""},{"location":"introduction/#what-is-dependency-injection","title":"What is Dependency Injection ?","text":"<p>If a class requires other classes as its attributes, then these attributes are regarded as dependencies of the class, and the class requiring them is called a dependent.</p> <pre><code>class Downloader:\n    def __init__(self, session: requests.Session):\n        self.session = session\n</code></pre> <p>Here, <code>Downloader</code> is a dependent, with <code>requests.Session</code> being its dependency.</p> <p>Dependency injection means dynamically constructing the instances of these dependency classes and then pass them to the dependent class.</p> <p>the same class without dependency injection looks like this:</p> <pre><code>class Downloader:\n    def __init__(self):\n        self.session = requests.Session(url=configured_url, timeout=configured_timeout)\n</code></pre> <p>Now, since <code>requests.Session</code> is automatically built with <code>Downloader</code>, it would be difficult to change the behavior of <code>requests.Session</code> at runtime.</p>"},{"location":"introduction/#why-do-we-need-it","title":"Why do we need it?","text":"<p>There are actually a few reasons why you might not need it, the most fundamental one being your code does not need reuseability and flexibility.</p> <ol> <li>If you are writing a script that only runs when you menually execute it, and it is often easier to rewrite the whole script than to modify it, then it probably more efficient to program everything hard-coded. This is actually a common use case of python, DEVOPS, DataAnalysts, etc.</li> </ol> <p>For example, you can actually modify the dependencies of a class at runtime.</p> <pre><code>class Downloader:\n    ...\n\ndownloader = Downloader()\ndownloader.session = requests.Session(url=configured_url, timeout=configured_timeout)\n</code></pre> <p>However, this creates a few problems:</p> <ul> <li>It is error-prone, you might forget to modify the dependencies, or you might modify the dependencies in the wrong order.</li> <li>It is not typesafe, you might pass the wrong type of dependencies to the class.</li> <li>It is hard to track when the dependencies are modified.</li> </ul> <p>Dependency injection enables you to extend the dependencies of a class without modifying the class itself, which increases the flexibility and reusability of the class.</p>"},{"location":"introduction/#do-we-need-a-di-framework","title":"Do we need a DI framework?","text":"<p>Not necessarily.</p> <p>You will be doing just fine using menual dependency injection, as long as the number of dependencies in your app stays within a managable range.</p> <p>It gets more and more helpful once your your dependency graph starts getting more complicated, For example, you might have something like this in your app, where you menually inject dependencies into dependent.</p> <p>Let's see an example:</p> factory.py<pre><code>from .infra import * \n\ndef auth_service_factory(\n    settings: Settings,\n) -&gt; AuthService:\n    connect_args = (\n        settings.db.connect_args.model_dump()\n    )\n    execution_options = (\n        settings.db.execution_options.model_dump()\n    )\n    engine = engine_factory(\n        db_url=settings.db.DB_URL,\n        echo=settings.db.ENGINE_ECHO,\n        isolation_level=settings.db.ISOLATION_LEVEL,\n        pool_pre_ping=True,\n        connect_args=connect_args,\n        execution_options=execution_options,\n    )\n    async_engine = sqlalchemy.ext.asyncio.AsyncEngine(engine)\n    db = AsyncDatabase(async_engine)\n    cache = RedisCache[str].build(\n        url=config.URL,\n        keyspace=config.keyspaces.APP,\n        socket_timeout=config.SOCKET_TIMEOUT,\n        decode_responses=config.DECODE_RESPONSES,\n        max_connections=config.MAX_CONNECTIONS,\n    )\n    token_registry = TokenRegistry(cahce=cache, \n        token_bucket=TokenBucket(cache, key=Settings.redis.bucket_key)\n    )\n    uow = UnitOfWork(db)\n    encryptor = Encryptor(\n        secret_key=settings.security.SECRET_KEY.get_secret_value(),\n        algorithm=settings.security.ALGORITHM,  \n    )\n    eventstore =  EventStore(uow)\n    auth_repo = AuthRepository(db)\n    auth_service = AuthService(\n        auth_repo=auth_repo,\n        token_registry=token_registry,\n        encryptor=encryptor,\n        eventstore=eventstore,\n        security_settings=settings.security,\n    )\n    return auth_service\n</code></pre> <p>But then you realize that some of these dependencies should be shared across your services, for example, auth repo might be needed by both AuthService and UserService, or even more</p> <p>You might also need to menually create and manage scope as some resources should be accessed/shared only whtin a certain scope, e.g., a request.</p>"},{"location":"introduction/#isnt-dependency-injection-a-java-thing","title":"isn't dependency injection a java thing?","text":"java like python code      <pre><code>import typing as ty\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\n\n\nclass Item(ABC):\n    price: float\n    quantity: int\n\n    @property\n    @abstractmethod\n    def cost(self) -&gt; float: ...\n\n\n@dataclass\nclass ItemBase(Item):\n    price: float\n    quantity: int\n\n    @property\n    def cost(self) -&gt; float:\n        return self.price * self.quantity\n\n\nclass Discount(ABC):\n    price_off: float\n\n\n@dataclass\nclass DiscountBase(Discount):\n    price_off: float\n\n\nclass AbstractShopCart(ty.Protocol):\n    items: ty.Sequence[Item]\n    discount: Discount\n\n\n@dataclass\nclass ShopCartBase:\n    items: ty.Sequence[Item]\n    discount: Discount\n\n    def total(self):\n        p: float = 0\n        for item in self.items:\n            p += item.cost * (1 - self.discount.price_off)\n        return p\n\n\n@dataclass\nclass EconomicShopCartImpl(ShopCartBase): ...\n\n\n@dataclass\nclass LuxuryShopCartImpl(ShopCartBase):\n    cart_rent: float\n\n    def total(self):\n        return super().total() + self.cart_rent\n\n\nclass ShopCartCreator(ABC):\n    @abstractmethod\n    def create(self, items: ty.Sequence[Item], discount: Discount) -&gt; ShopCartBase: ...\n\n\nclass LuxuryShopCartCreator(ShopCartCreator):\n    def __init__(self, cart_rent: float):\n        self.cart_rent: float = cart_rent\n\n    def create(\n        self, items: ty.Sequence[Item], discount: Discount\n    ) -&gt; LuxuryShopCartImpl:\n        if discount.price_off &gt; 0.5:\n            raise ValueError(\n                f\"Discount with price off higher than 50% can't be applied to luxury shop cart\"\n            )\n        return LuxuryShopCartImpl(\n            items=items, discount=discount, cart_rent=self.cart_rent\n        )\n\n\nclass EconomicsShopCartCreator(ShopCartCreator):\n    def create(\n        self, items: ty.Sequence[Item], discount: Discount\n    ) -&gt; EconomicShopCartImpl:\n        return EconomicShopCartImpl(items, discount=discount)\n\n\nclass ShopCartFactoryManager:\n    def __init__(self):\n        self._creator_mapping: dict[str, ShopCartCreator] = {}\n\n    def register_creator(self, cart_type: str, creator: ShopCartCreator):\n        self._creator_mapping[cart_type] = creator\n\n    def create_cart(\n        self, cart_type: str, items: ty.Sequence[Item], discount: Discount\n    ) -&gt; ShopCartBase:\n        try:\n            return self._creator_mapping[cart_type].create(items, discount)\n        except KeyError:\n            raise ValueError(f\"{cart_type} is not registered with a creator\")\n\n\nclass ShopCartFactoryManagerBuilder:\n    def __init__(self):\n        self._manager = ShopCartFactoryManager()\n\n    def with_economic_cart(self):\n        self._manager.register_creator(\"economic\", EconomicsShopCartCreator())\n        return self\n\n    def with_luxury_cart(self, cart_rent: float):\n        creator = LuxuryShopCartCreator(cart_rent=cart_rent)\n        self._manager.register_creator(\"luxury\", creator)\n        return self\n\n    def build(self) -&gt; ShopCartFactoryManager:\n        return self._manager\n\n\nclass AbstractShoprtCartFactoryManagerBuilderFactory(ABC):\n    @abstractmethod\n    def _pre_create(self): ...\n\n    @abstractmethod\n    def create_builder(self) -&gt; ShopCartFactoryManagerBuilder:\n        pass\n\n\nclass ShoprtCartFactoryManagerBuilderFactoryBase(\n    AbstractShoprtCartFactoryManagerBuilderFactory\n):\n    \"\"\"Base implementation of AbstractShoprtCartFactoryManagerBuilderFactory.\"\"\"\n\n    @abstractmethod\n    def _pre_create(self): ...\n\n    def create_builder(self) -&gt; ShopCartFactoryManagerBuilder:\n        self._pre_create()\n        return ShopCartFactoryManagerBuilder()\n\n\nclass ShoprtCartFactoryManagerBuilderFactoryimpl(\n    ShoprtCartFactoryManagerBuilderFactoryBase\n):\n    \"\"\"Concrete implementation of the factory.\"\"\"\n\n    def _pre_create(self):\n        print(\"Hello, World!\")\n\n\nclass Application:\n    def run(self):\n        # Build the factory manager\n        builder_factory = ShoprtCartFactoryManagerBuilderFactoryimpl()\n        builder = builder_factory.create_builder()\n        factory_manager = (\n            builder.with_economic_cart().with_luxury_cart(cart_rent=50.0).build()\n        )\n\n        # Create economic cart\n        items = [ItemBase(price=100, quantity=2)]\n        discount = DiscountBase(price_off=0.1)\n        economic_cart = factory_manager.create_cart(\"economic\", items, discount)\n        print(economic_cart.total())\n\n        # Create luxury cart\n        luxury_cart = factory_manager.create_cart(\"luxury\", items, discount)\n        print(luxury_cart.total())\n\n\nif __name__ == \"__main__\":\n    Application().run()\n</code></pre> <p>the same logic, but pythonic, with only 1/3 LOC.</p>      pythonic python code      <pre><code>import typing as ty\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Item:\n    price: float\n    quantity: int\n\n    @property\n    def cost(self) -&gt; float:\n        return self.price * self.quantity\n\n\n@dataclass\nclass Discount:\n    price_off: float\n\n\n@dataclass\nclass ShopCart:\n    items: ty.Sequence[Item]\n    discount: Discount\n\n    def total(self):\n        p: float = 0\n        for item in self.items:\n            p += item.cost * (1 - self.discount.price_off)\n        return p\n\n\n@dataclass\nclass EconomicShopCart(ShopCart): ...\n\n\n@dataclass\nclass LuxuryShopCart(ShopCart):\n    cart_rent: float\n\n    def total(self):\n        return super().total() + self.cart_rent\n\n\ndef create_cart(\n    items: ty.Sequence[Item], discount: Discount, *, cart_rent: float | None = None\n) -&gt; ShopCart:\n    print(\"Hello, World\")\n\n    if cart_rent:\n        return LuxuryShopCart(items=items, discount=discount, cart_rent=cart_rent)\n    return EconomicShopCart(items=items, discount=discount)\n\n\ndef main():\n    # Create economic cart\n    items = [Item(price=100, quantity=2)]\n    discount = Discount(price_off=0.1)\n\n    economic_cart = create_cart(items, discount)\n    print(economic_cart.total())\n\n    # Create luxury cart\n    luxury_cart = create_cart(items, discount, cart_rent=50)\n    print(luxury_cart.total())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"openclosed/","title":"Open Closed Principle","text":""},{"location":"openclosed/#original-meaning","title":"Original meaning","text":"<p>software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification</p> <ul> <li> <p>A module will be said to be open if it is still available for extension. For example, it should be possible to add fields to the data structures it contains, or new elements to the set of functions it performs.</p> </li> <li> <p>A module will be said to be closed if it is available for use by other modules. This assumes that the module has been given a well-defined, stable description (the interface in the sense of information hiding).</p> </li> </ul> <p>Interpretation:</p> <p>Open for extension: you can add new functionality. Closed for modification: you can't change existing code that others dependent on</p> <p>In short: don't modify existing software entiies, add new software entities with the changes needed.</p> <p>Example:</p> <p>In the core of my lib ididi, is a class <code>Graph</code>, where user use it likethis</p> <p><code>factory.py</code></p> <pre><code>from ididi import Graph\n\ndg = Graph()\n</code></pre> <p>Since users are now dependent on Graph, it is considered as <code>closed</code>. We should no longer modify the existing interface of <code>Graph</code> that as it might create breaking changes.</p> <p>e.g.</p> <pre><code>class Graph:\n    def __init__(self, name: str): ...\n\n\n    def get_name(self) -&gt; str: return self.name\n</code></pre> <p>Now this breaks the client code that calls <code>Graph()</code>, since it now requires a <code>name</code> parameter.</p> <p>what we should do instead, it create a new subclass inherit from <code>Graph</code>, with changes needed.</p> <pre><code>class NamedGraph(Graph):\n    def __init__(self, name: str): ...\n\n    def get_name(self) -&gt; str: return self.name\n</code></pre> <p>Now, user's code that call <code>DependnecyGraph()</code> won't break, and if they need the new added functionality, they call <code>NamedGraph</code>.</p>"},{"location":"openclosed/#an-evolvement-in-the-90s","title":"An evolvement in the 90s","text":"<p>During the 1990s, the open\u2013closed principle became popularly redefined to refer to the use of abstracted interfaces, where the implementations can be changed and multiple implementations could be created and polymorphically substituted for each other.</p> <p>In contrast to Meyer's usage, this definition advocates inheritance from abstract base classes. Interface specifications can be reused through inheritance but implementation need not be. The existing interface is closed to modifications and new implementations must, at a minimum, implement that interface.</p> <pre><code>class AbstractGraph:\n    def get_name(self) -&gt; str: ...\n</code></pre>"},{"location":"performance/","title":"Performance","text":"<p>ididi is very efficient and performant, with average time complexity of O(n)</p>"},{"location":"performance/#graphstatical_resolve-type-analysis-on-each-class-can-be-done-at-import-time","title":"<code>Graph.statical_resolve</code> (type analysis on each class, can be done at import time)","text":"<p>Time Complexity: O(n) - O(n**2)</p> <p>O(n): average case, where each dependent has a constant number of dependencies, for example, each dependents has on average 3 dependencies.</p> <p>O(n**2): worst case, where each dependent has as much as possible number of dependencies, for example, with 100 nodes, node 1 has 99 dependencies, node 2 has 98, etc.</p> <p>I personally don't think anyone would ever encouter the worse case in real-world, but even if someone does, you can still expect ididi resolve thousand of such classes in seoncds.</p> <p>As a reference:</p> <p>tests/test_benchmark.py 0.003801 seoncds to statically resolve 122 classes</p>"},{"location":"performance/#graphresolve-inject-dependencies-and-build-the-dependent-instance","title":"<code>Graph.resolve</code> (inject dependencies and build the dependent instance)","text":"<p>Time Complexity: O(n)</p> <p>You might run the benchmark yourself with following steps</p> <ol> <li>clone the repo, cd to project root</li> <li>install pixi from pixi</li> <li>run <code>pixi install</code></li> <li>run <code>make benchmark</code></li> </ol>"},{"location":"performance/#performance-tip","title":"Performance tip","text":"<ul> <li> <p>use dg.node to decorate your classes</p> </li> <li> <p>use dg.node to decorate factory of third party classes so that ididi does not need to analyze them</p> </li> </ul> <p>For Example</p> <pre><code>def redis_factory(settings: Settings) -&gt; Redis:\n    # build redis here\n    return redis\n</code></pre> <ul> <li>use dg.analyze_nodes when your app starts, which will statically resolve all your classes decorated with @dg.node.</li> </ul> <p>However, ididi is so performant so most of time there is no reason to apply these tips.</p>"},{"location":"performance/#resolve-rules","title":"Resolve Rules","text":"<ul> <li>If a node has a factory, it will be used to create the instance.</li> <li>Otherwise, the node will be created using the <code>__init__</code> method.</li> <li>Parent's <code>__init__</code> will be called if no <code>__init__</code> is defined in the node.</li> <li>whenver there is a default value, it will be used to resolve the dependency.</li> <li>bulitin types are not resolvable by nature, it requires default value to be provided.</li> <li>runtime override with <code>dg.resolve</code></li> </ul>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#two-primitives","title":"Two primitives","text":"<p>In most cases, you will only need these two primitive method for buliding your dpendent/dependency</p> <ul> <li><code>dg.resolve</code></li> </ul> <p>you can either resolve a dependent class</p> <pre><code>dg = Graph()\n\ndg.resolve(UserService)\n</code></pre> <p>or a factory function that return the dependent class.</p> <pre><code>def get_user_service(user_repo: UserRepo) -&gt; UserService:\n    return UserService(user_repo)\n\ndg.resolve(get_user_service)\n</code></pre> <p>or both</p> <pre><code>def get_user_service() -&gt; UserService:\n    return dg.resolve(UserService)\n</code></pre> <ul> <li><code>dg.scope</code></li> </ul> <p>scope is like Graph, but for resouces. you can pass them around as you need,</p> <pre><code>async with dg.ascope() as scope:\n    conn = await scope.resolve(Connection)\n    await exec_sql(conn)\n</code></pre>"},{"location":"tutorial/#usage-with-fastapi","title":"Usage with FastAPI","text":"app.py<pre><code>from fastapi import FastAPI\nfrom ididi import Graph\n\napp = FastAPI()\ndg = Graph()\n\ndef auth_service_factory() -&gt; AuthService:\n    async with dg.ascope() as scope\n        yield dg.resolve(AuthService)\n\nService = ty.Annotated[AuthService, Depends(auth_service_factory)]\n\n@app.get(\"/\")\ndef get_service(service: Service):\n    return service\n</code></pre> <p>[!NOTE] Graph does NOT have to be a global singleton</p> <p>Although we use <code>dg</code> extensively to represent an instance of Graph for the convenience of explaination, it DOES NOT mean it has to be a global singleton. These are some examples you might inject it into your fastapi app at different levels.</p>"},{"location":"tutorial/#graph-as-an-app-level-instance","title":"Graph as an app-level instance","text":"<pre><code>import typing as ty\n\nfrom fastapi.routing import APIRoute, APIRouter\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\nfrom ididi import Graph\n\n\nclass GraphedScope(ty.TypedDict):\n    dg: Graph\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI | None = None) -&gt; ty.AsyncIterator[GraphedScope]:\n    async with Graph() as dg:\n        yield {\"dg\": dg}\n\n\n@app.post(\"/users\")\nasync def signup_user(request: Request):\n    dg = request.state.dg\n    service = dg.resolve(UserService)\n    user_id = await service.signup_user(...)\n    return user_id\n</code></pre>"},{"location":"tutorial/#injecting-graph-at-route-level","title":"Injecting Graph at route level","text":"<pre><code>class UserRoute(APIRoute):\n    def get_route_handler(self) -&gt; ty.Callable[[Request], ty.Awaitable[Response]]:\n        original_route_handler = super().get_route_handler()\n\n        async def custom_route_handler(request: Request) -&gt; Response:\n\n            dg = Graph()\n            request.scope[\"dg\"] = dg\n\n            async with dg.ascope() as user_scope:\n                response = await original_route_handler(request)\n                return response\n\n        return custom_route_handler\n\nuser_router = APIRouter(route_class=UserRoute)\n</code></pre>"},{"location":"tutorial/#injecting-graph-at-request-level","title":"Injecting Graph at request level","text":"<pre><code>class GraphedMiddleware:\n    def __init__(self, app, dg: Graph):\n        self.app = app\n        self.dg = dg\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send):\n        # NOTE: remove follow three lines would break lifespan\n        # as startlette would pass lifespan event here\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        scope[\"dg\"] = self.dg\n        await self.app(scope, receive, send)\n\n\napp.add_middleware(GraphedMiddleware, dg=Graph)\n</code></pre>"},{"location":"tutorial/#usage-of-factory","title":"Usage of factory","text":""},{"location":"tutorial/#using-factory-to-override-dependency-injection","title":"Using factory to override dependency injection","text":"<p>There are cases where you would like to menually build the dependency yourself with a factory function,</p>"},{"location":"tutorial/#menually-config-details-of-external-libraries","title":"Menually config details of external libraries","text":"<pre><code>@dg.node\ndef engine_factory(config: Config)-&gt; sqlalchemy.engine.Engine:\n    engine = create_engine(\n        url=config.db.URL,\n        pool_recycle=config.db.POOL_RECYCLE,\n        isolation_level=config.db.ISOLATION_LEVEL\n    )\n    return engine\n</code></pre> <ul> <li>Privide a stub for your dependencies for testing.</li> </ul> <pre><code>@dg.node\ndef fake_engine_factory(config: Config)-&gt; sqlalchemy.engine.Engine:\n    return FakeEngine()\n\n@pytest.fixture\ndef engine():\n    return dg.resolve(Engine)\n</code></pre> <ul> <li>Provide different implementation of the dependencies based on some condition.</li> </ul> <pre><code>@dg.node\ndef redis_cache(config: Config) -&gt; redis.Redis:\n    if config.RUNTIME_ENV == 'prod':\n        return redis.Redis(...)\n    return redis.Redis(...)\n</code></pre> <ul> <li>Assign a implementation for parent class</li> </ul> <pre><code>class Storage:\n    ...\nclass Database(Storage):\n    ...\nclass S3(Storage): \n    ...\n\n@dg.node\ndef storage_factory(config: Config) -&gt; Storage:\n    if config.storage.storage_type = \"cold\":\n        return S3(...)\n    return Database(...)\n</code></pre> <p>This works for ABC, typing.Protocol, as well as plain classes.</p> <p><code>Graph.node</code> accepts a wide arrange of types, such as dependent class, sync/async facotry, sync/async resource factory, with typing support.</p>"}]}